00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 11/30/2019 9:17:35 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :
00000000                             3  * Written by :
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8      
00001000  =00000006                  9  trap_p_char equ 6
00001000  =0000000D                 10  trap_p_nullterm_crlf equ 13
00001000                            11  
00001000  =00000002                 12  node_next equ 2 ; offset within a node struct of the pointer to the next node
00001000                            13  
00001000                            14  START:                  ; first instruction of program
00001000                            15  
00001000  4EB9 000010E0             16      jsr print_list * Print initial state of the list.
00001006                            17      
00001006                            18      * Insert sorting implementation here.
00001006  4DF9 00001108             19      lea.l list_head, A6
0000100C  4EB9 0000101C             20      jsr merge_sort
00001012                            21      
00001012  4EB9 000010E0             22      jsr print_list * Print the now-sorted list.
00001018  FFFF FFFF                 23      SIMHALT
0000101C                            24  
0000101C                            25  * SUBROUTINE
0000101C                            26  * Pass a double pointer to the head of a linked list to A6.L.
0000101C                            27  * Sorts the linked list.
0000101C                            28  merge_sort
0000101C  48E7 0186                 29      movem.l D7/A0/A5/A6, -(SP)
00001020                            30      * Check if the list is size 1.
00001020                            31      * All lists of size 1 are sorted.
00001020  4EB9 00001058             32      jsr length
00001026  BEBC 00000001             33      cmp.l #1, D7
0000102C  6F00 0024                 34      ble ms_sorted
00001030                            35      * else
00001030                            36          * Split the list.
00001030  2A4E                      37          move.l A6, A5
00001032  4EB9 00001076             38          jsr split
00001038                            39          * Sort the two halves.
00001038  2F0E                      40          move.l A6, -(SP)
0000103A  204F                      41          move.l SP, A0
0000103C  2C48                      42          move.l A0, A6
0000103E  4EB8 101C                 43          jsr merge_sort
00001042  2C4D                      44          move.l A5, A6
00001044  4EB8 101C                 45          jsr merge_sort
00001048  2C48                      46          move.l A0, A6
0000104A                            47          * Merge the two sorted halves.
0000104A  4EB9 00001098             48          jsr merge
00001050  2C5F                      49          move.l (SP)+, A6
00001052                            50  ms_sorted
00001052  4CDF 6180                 51      movem.l (SP)+, D7/A0/A5/A6
00001056  4E75                      52      rts
00001058                            53  
00001058                            54  * SUBROUTINE
00001058                            55  * Pass a double pointer to the first node in A6.L.
00001058                            56  * Returns the length of the list in D7.L.
00001058                            57  length
00001058  48E7 2020                 58      movem.l D2/A2, -(SP)
0000105C  4287                      59      clr.l D7
0000105E  2416                      60      move.l (A6), D2
00001060                            61  length_loop
00001060                            62      * Check if next node is null.
00001060  4A82                      63      tst.l D2
00001062  6700 000C                 64      beq length_cleanup
00001066                            65          * Increment counter move to next node.
00001066  2442                      66          move.l D2, A2
00001068  548A                      67          addq.l #node_next, A2
0000106A  2412                      68          move.l (A2), D2
0000106C  5287                      69          addq.l #1, D7
0000106E  60F0                      70      bra length_loop
00001070                            71  length_cleanup
00001070  4CDF 0404                 72      movem.l (SP)+, D2/A2
00001074  4E75                      73      rts
00001076                            74      
00001076                            75  * SUBROUTINE
00001076                            76  * Pass a double pointer to the first node in A5.L.
00001076                            77  * Pass the length of the list in D7.L.
00001076                            78  * Sets the element before the midpoint's next to null.
00001076                            79  * Returns the address of the midpoint in A6.L.
00001076                            80  split
00001076  48E7 0104                 81      movem.l D7/A5, -(SP)
0000107A  E28F                      82      lsr.l #1, D7
0000107C  2C4D                      83      move.l A5, A6
0000107E                            84  split_loop
0000107E  4A87                      85      tst.l D7
00001080  6700 000A                 86      beq split_cleanup
00001084  2C56                      87          move.l (A6), A6
00001086  548E                      88          addq.l #node_next, A6
00001088  5387                      89          subq.l #1, D7
0000108A  60F2                      90      bra split_loop
0000108C                            91  split_cleanup
0000108C  2A56                      92      move.l (A6), A5
0000108E  4296                      93      clr.l (A6)
00001090  2C4D                      94      move.l A5, A6
00001092  4CDF 2080                 95      movem.l (SP)+, D7/A5
00001096  4E75                      96      rts
00001098                            97      
00001098                            98  * SUBROUTINE
00001098                            99  * Pass a double pointer to the first nodes of each of two
00001098                           100  * sorted lists to A5.L ("left") and A6.L ("right").
00001098                           101  * Merges the lists and returns a double pointer to the
00001098                           102  * merged list in A5.L.
00001098                           103  * The contents of A6.L are undefined after calling this
00001098                           104  * subroutine.
00001098                           105  merge
00001098  48E7 3034                106      movem.l D2/D3/A2/A3/A5, -(SP)
0000109C                           107  merge_loop
0000109C  4A95                     108      tst.l (A5)
0000109E  6700 002A                109      beq merge_left_empty
000010A2  4A96                     110      tst.l (A6)
000010A4  6700 0026                111      beq merge_right_empty
000010A8  2455                     112          move.l (A5), A2
000010AA  1412                     113          move.b (A2), D2
000010AC  2656                     114          move.l (A6), A3
000010AE  1613                     115          move.b (A3), D3
000010B0  B403                     116          cmp.b D3, D2
000010B2  6F00 0010                117          ble merge_less_or_equal
000010B6                           118  merge_greater
000010B6                           119              * Store the "next" of the right list.
000010B6  2456                     120              move.l (A6), A2
000010B8  548A                     121              addq.l #node_next, A2
000010BA                           122              * Insert the head of the right list into the left list.
000010BA  2C56                     123              move.l (A6), A6
000010BC  4EB9 000010D2            124              jsr insert
000010C2                           125              * Replace the right list with the stored head.
000010C2  2C4A                     126              move.l A2, A6
000010C4                           127              * We just moved back up one in the left list, so fallthrough to
000010C4                           128              * move back down.
000010C4                           129  merge_less_or_equal
000010C4                           130              * Go to next on left list.
000010C4  2A55                     131              move.l (A5), A5
000010C6  548D                     132              addq.l #node_next, A5
000010C8  60D2                     133          bra merge_loop
000010CA                           134      
000010CA                           135  merge_left_empty
000010CA                           136      * Append the right list to the end of the left list.
000010CA  2A96                     137      move.l (A6), (A5)
000010CC                           138      * Fallthrough to merge_cleanup.
000010CC                           139  merge_right_empty
000010CC                           140      * Everything has been merged into the left list--nothing left to do.
000010CC                           141      * Fallthrough to merge_cleanup.
000010CC                           142  merge_cleanup
000010CC  4CDF 2C0C                143      movem.l (SP)+, D2/D3/A2/A3/A5
000010D0  4E75                     144      rts
000010D2                           145  
000010D2                           146  * SUBROUTINE
000010D2                           147  * Pass a pointer to the "next" field of the node to insert after to A5.
000010D2                           148  * Pass a pointer to the node to insert to A6.
000010D2                           149  insert
000010D2  2F08                     150      move.l A0, -(SP)
000010D4  204E                     151      move.l A6, A0
000010D6  5488                     152      addq.l #node_next, A0   ; A0 now points to the "next" field of the node
000010D8                           153                              ; we're inserting.
000010D8                           154      * Move the node currently pointed to by the passed "next" to the "next"
000010D8                           155      * of the node that's getting inserted before it.
000010D8  2095                     156      move.l (A5), (A0)
000010DA                           157      * Replace the moved node with the one passed to A6.
000010DA  2A8E                     158      move.l A6, (A5)
000010DC                           159      * Cleanup.
000010DC  205F                     160      move.l (SP)+, A0
000010DE  4E75                     161      rts
000010E0                           162      
000010E0                           163  * SUBROUTINE
000010E0                           164  * Prints the list.
000010E0                           165  print_list
000010E0  48E7 E040                166      movem.l D0/D1/D2/A1, -(SP)
000010E4  43F9 00001108            167      lea.l list_head, A1
000010EA                           168  pl_loop
000010EA  2411                     169      move.l (A1), D2
000010EC  4A82                     170      tst.l D2
000010EE  6700 000E                171      beq pl_cleanup
000010F2  2251                     172      move.l (A1), A1
000010F4  1211                     173      move.b (A1), D1
000010F6  7006                     174      move.l #trap_p_char, D0
000010F8  4E4F                     175      trap #15
000010FA  5489                     176      add.l #node_next, A1
000010FC  60EC                     177      bra pl_loop
000010FE                           178  pl_cleanup
000010FE  700D                     179      move.l #trap_p_nullterm_crlf, D0
00001100  4E4F                     180      trap #15
00001102  4CDF 0207                181      movem.l (SP)+, D0/D1/D2/A1
00001106  4E75                     182      rts
00001108                           183  
00001108                           184  * Put variables and constants here
00001108                           185  
00001108                           186  list_head ; pointer to the first node in the list
00001108= 0000110C                 187      dc.l b_node
0000110C                           188  b_node
0000110C= 62                       189      dc.b 'b'
0000110E= 00001112                 190      dc.l a_node
00001112                           191  a_node
00001112= 61                       192      dc.b 'a'
00001114= 00000000                 193      dc.l 0 ;e_node
00001118                           194  c_node
00001118= 63                       195      dc.b 'c'
0000111A= 00000000                 196      dc.l 0
0000111E                           197  d_node
0000111E= 64                       198      dc.b 'd'
00001120= 00001118                 199      dc.l c_node
00001124                           200  e_node
00001124= 65                       201      dc.b 'e'
00001126= 0000111E                 202      dc.l d_node
0000112A                           203      
0000112A                           204      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A_NODE              1112
B_NODE              110C
C_NODE              1118
D_NODE              111E
E_NODE              1124
INSERT              10D2
LENGTH              1058
LENGTH_CLEANUP      1070
LENGTH_LOOP         1060
LIST_HEAD           1108
MERGE               1098
MERGE_CLEANUP       10CC
MERGE_GREATER       10B6
MERGE_LEFT_EMPTY    10CA
MERGE_LESS_OR_EQUAL  10C4
MERGE_LOOP          109C
MERGE_RIGHT_EMPTY   10CC
MERGE_SORT          101C
MS_SORTED           1052
NODE_NEXT           2
PL_CLEANUP          10FE
PL_LOOP             10EA
PRINT_LIST          10E0
SPLIT               1076
SPLIT_CLEANUP       108C
SPLIT_LOOP          107E
START               1000
TRAP_P_CHAR         6
TRAP_P_NULLTERM_CRLF  D
